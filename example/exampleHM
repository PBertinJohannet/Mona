data Maybe a = Nil | Just a | P a a;
data Option a = Some a | None + JustSome Just(Some);
data Prod a b = P a b;
data Maybe a = Nil | Just a;
data App f a = A (f a);
data Inl a = Inl (List a);
data Cmp a = Cmp (App Maybe a);
data Nat = N (fix Maybe);
data Lam = L (\e -> Maybe e) | None;
data Bool = True | False;
let flip = \f a b -> f b a;
let facf = \f a -> if a == 0 then a else (f a);
let o = \l -> l + 1;
let p = \l -> if l == 0 then 5 else l + 1;
let ift = \c t f -> if c then t else f;
let fac = fix facf;
let faccinq = fac 5;
let dbl = \f a b -> (f a) : b;
let ok = dbl (\a -> a == 0);
let lstok = \a b -> a ++ b;
let dots = \a b -> a : b;
let fdots = flip dots;
let inlist = \a -> [a];
let numsa = (dots) 2 [1];
let numsb = (flip dots) [1] 2;
let numsc = [1, 2, 3, 4, 5, 3];
let numsd = [False, True, 1 == 2, (\a -> a == 1) 2];
let numse = [\a -> a == 2, \b -> (fac b) == 20];
let e = let a = (\x -> x + x) in \f c -> f (a (a (a c)));
let k = \f -> show (f);
let k2 = \f -> show (f + 1);
let i = \k -> show [k];
let v = \f b -> show (f b);
let k3 = \f b -> show ((\e -> f) b);
let inL a = [a];
let ot = \(Just a) -> a;
let out = \(Just a) -> inL a;
data Nat = Nat (fix Maybe);
let fromNat f = \(Nat (Just a)) -> 1 + (f a);
let toInt = fix fromNat;
let fromInt f a = if a == 0 then Nat Nil else Nat (Just (f (a-1)));
let toNat = fix fromInt;
data Prod a b = Prod a b + Fst \a b c -> (Prod (Prod a b) c);
data Maybe a = Nil | Just a;
data ListF f a = EndF | ConsF a (f a);
data List a  = List ((fix ListF) a)
  + Cons (\a b -> List(ConsF a b))
  + End List(EndF)
  + CCons \a b c -> Cons a (Cons b c);

let expr e = case e of
  (Just a) -> a + 1,
  (Nil) -> 0;
let lenf f l = case l of
  (Cons a b) -> 1 + (f b),
  (End) -> 0;
let len = fix lenf;
