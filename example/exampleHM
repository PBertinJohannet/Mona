
class Functor f = {
  sig fmap = forall a b . (a -> b) -> (f a) -> f b;
}
data ListF f a = EndF | ConsF a (f a);
data List a  = List ((fix ListF) a)
  + Cons (\a b -> List(ConsF a b))
  + End List(EndF)
  + CCons \a b c -> Cons a (Cons b c);


inst List of Functor = {
  let fmap f l = case l of
    (End) -> End,
    (Cons a b) -> (Cons (f a)) (fmap f b);
}
