sig flip = forall a b c . (a -> b -> c) -> b -> a -> c;
let flip = \f a b -> (f b) a;

sig add = Int -> Int -> Int
let add a b = a + b;

data Unit = Unit;
data Bool = True | False;

class Read a = {
  sig read = (List Char) -> a;
};
class Functor f = {
  sig fmap = forall a b . (a -> b) -> (f a) -> f b;
}
class Monad m = {
  sig return = forall a . m a;
  sig bind = forall a b . (a -> m b) -> (m a) -> (m b);
}
inst Int of Read = {
  let read k = 1;
}

data ListF f a = EndF | ConsF a (f a);
data List a  = List ((fix ListF) a);
let Cons = (\a b -> List(ConsF a b));
sig End = forall a . List a;
let End = List(EndF);

inst List of Functor = {
  let fmap f = \(List l) -> case l of
    (EndF) -> End,
    (ConsF a b) -> (Cons (f a)) End;
}

class NeedMul a = {
  sig func = forall b . Functor b => (b a) -> (b a);
}

inst Int of NeedMul = {
  let func x = x;
}

let difmap f a = fmap (fmap f) a;

let choseFrom a b c = b;

let ot = func [1];

sig printAllLn = (List Int) -> List (IO Unit);
let printAllLn = fmap printInt;

sig fac = Int -> Int;
let fac a = case (a == 0) of
  (True) -> 1,
  (False) -> a * (fac (a - 1));

sig choose = forall a . Bool -> Int -> Int -> Int
let choose c a b = case c of
  (False) -> a,
  (True) -> (2 + b);

let main = [printInt (fac 6), printChar endl];
