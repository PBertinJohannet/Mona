datas :
L i s t F
f a
((((EndF) | (ConsF)) (a)) ((f) (a)))
 L i s t
a
((((+) (((((+) ((((+) ((List) ((fix (ListF)) (a)))) (Cons)) (\a -> (\b -> ((List) (((ConsF) (a)) (b))))))) (End)) (List)) (EndF))) (CCons)) (\a -> (\b -> (\c -> (((Cons) (a)) (((Cons) (b)) (c)))))))
exprs :
flip = (\f -> (\a -> (\b -> (((f) (b)) (a)))))
 add = (\a -> (\b -> (((+) (a)) (b))))
base : (((ConsF) (a)) ((f) (a))) (EndF)
additionals :
found : 'a -> 'b -> 'c -> 'd -> 'j
solve :
'e -> 'e -> 'e should unify with : 'd -> 'f
 'c should unify with : 'b -> 'g
 'a should unify with : 'b -> 'h
 'g should unify with : 'h -> 'i
 'f should unify with : 'i -> 'j

unify : 'e -> 'e -> 'e and 'd -> 'f
found : 'e is 'd
 'f is 'd -> 'd

unify : 'c and 'b -> 'g
found : 'c is 'b -> 'g

unify : 'a and 'b -> 'h
found : 'a is 'b -> 'h

unify : 'g and 'h -> 'i
found : 'g is 'h -> 'i

unify : 'd -> 'd and 'i -> 'j
found : 'd is 'j
 'i is 'j

baseT is : ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*})
baseT is : ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*})
created :
ListF : (* -> *) -> * -> *
constructing : ListF f a
 of type  : (a -> a) -> a -> a
 with tvars : f{* -> *} a{*}
 constructors :
ConsF = forall f{* -> *} a{*} .  => a{*} -> f{* -> *} (a{*}) -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*})
 EndF = forall f{* -> *} a{*} .  => ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*})


 and patterns :
~ConsF = forall b{*} f{* -> *} a{*} .  => (a{*} -> f{* -> *} (a{*}) -> b{*}) -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*}) -> b{*}
 ~EndF = forall b{*} f{* -> *} a{*} .  => b{*} -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*}) -> b{*}


base : ((List) ((fix (ListF)) (a)))
additionals : ((CCons) (\a -> (\b -> (\c -> (((Cons) (a)) (((Cons) (b)) (c))))))) (((End) (List)) (EndF)) ((Cons) (\a -> (\b -> ((List) (((ConsF) (a)) (b))))))
found : 'a -> 'b -> 'g
solve :
'e -> 'e should unify with : ('d -> 'd) -> 'd -> 'd
 'e should unify with : 'a -> 'f
 'b should unify with : 'f -> 'g

unify : 'e -> 'e and ('d -> 'd) -> 'd -> 'd
found : 'e is 'd -> 'd

unify : 'd -> 'd and 'a -> 'f
found : 'a is 'f
 'd is 'f

unify : 'b and 'f -> 'g
found : 'b is 'f -> 'g

baseT is : [a{*}]
created :
List : * -> *
constructing : [a]
 of type  : a -> a
 with tvars : a{*}
 constructors :
List = forall a{*} .  => ListF ((* -> *) -> * -> *) (List (* -> *)) (a{*}) -> [a{*}]


 and patterns :
~List = forall b{*} a{*} .  => (ListF ((* -> *) -> * -> *) (List (* -> *)) (a{*}) -> b{*}) -> [a{*}] -> b{*}


got : (\a -> (\b -> ((List) (((ConsF) (a)) (b)))))
found : 'a -> 'b -> 'h
solve :
'e -> 'd 'e -> ListF 'd 'e should unify with : 'a -> 'f
 'f should unify with : 'b -> 'g
 ListF List 'c -> ['c] should unify with : 'g -> 'h

unify : 'e -> 'd 'e -> ListF 'd 'e and 'a -> 'f
found : 'e is 'a
 'f is 'd 'a -> ListF 'd 'a

unify : 'd 'a -> ListF 'd 'a and 'b -> 'g
found : 'b is 'd 'a
 'g is ListF 'd 'a

unify : ListF List 'c -> ['c] and ListF 'd 'a -> 'h
found : 'c is 'a
 'd is List
 'h is ['a]

infered : forall a . a -> [a] -> [a]
got : ((List) (EndF))
found : 'd
solve :
ListF List 'a -> ['a] should unify with : ListF 'b 'c -> 'd

unify : ListF List 'a -> ['a] and ListF 'b 'c -> 'd
found : 'a is 'c
 'b is List
 'd is ['c]

infered : forall a . [a]
got : (\a -> (\b -> (\c -> (((Cons) (a)) (((Cons) (b)) (c))))))
found : 'a -> 'b -> 'c -> 'i
solve :
'd -> ['d] -> ['d] should unify with : 'a -> 'e
 'f -> ['f] -> ['f] should unify with : 'b -> 'g
 'g should unify with : 'c -> 'h
 'e should unify with : 'h -> 'i

unify : 'd -> ['d] -> ['d] and 'a -> 'e
found : 'd is 'a
 'e is ['a] -> ['a]

unify : 'f -> ['f] -> ['f] and 'b -> 'g
found : 'f is 'b
 'g is ['b] -> ['b]

unify : ['b] -> ['b] and 'c -> 'h
found : 'c is ['b]
 'h is ['b]

unify : ['a] -> ['a] and ['b] -> 'i
found : 'a is 'b
 'i is ['b]

infered : forall a . a -> a -> [a] -> [a]
add classes : F u n c t o r
f
fmap = forall a b . (a -> b) -> f a -> f b


 =>
 F u n c t o r
List
fmap = (\f -> (\l -> (case (l) of ((~End) (End))
((~Cons) (\a -> (\b -> (((Cons) ((f) (a))) (((fmap) (f)) (b))))))
)))


 M o n a d
m
return = forall a . m a
 bind = forall a b . (a -> m b) -> m a -> m b


 =>

 R e a d
a
read = List Char -> a


 =>
 R e a d
Int
read = (\k -> (1))



inst to check : check : forall a b . (a -> b) -> [a] -> [b] vs (\f -> (\l -> (case (l) of ((~End) (End))
((~Cons) (\a -> (\b -> (((Cons) ((f) (a))) (((fmap) (f)) (b))))))
)))
 check : [Char] -> Int vs (\k -> (1))

after sigs : Vars :
* :  => Int (*) -> Int (*) -> Int (*)
+ :  => Int (*) -> Int (*) -> Int (*)
++ : forall a{*} .  => [a{*}] -> [a{*}] -> [a{*}]
- :  => Int (*) -> Int (*) -> Int (*)
. :  => (b{*} -> c{*}) -> (a{*} -> b{*}) -> a{*} -> c{*}
: : forall a{*} .  => a{*} -> [a{*}] -> [a{*}]
== :  => Int (*) -> Int (*) -> Bool (*)
CCons : forall a{*} .  => a{*} -> a{*} -> [a{*}] -> [a{*}]
Cons : forall a{*} .  => a{*} -> [a{*}] -> [a{*}]
ConsF : forall f{* -> *} a{*} .  => a{*} -> f{* -> *} (a{*}) -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*})
End : forall a{*} .  => [a{*}]
EndF : forall f{* -> *} a{*} .  => ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*})
List : forall a{*} .  => ListF ((* -> *) -> * -> *) (List (* -> *)) (a{*}) -> [a{*}]
[] : forall a{*} .  => [a{*}]
add :  => Int (*) -> Int (*) -> Int (*)
bind : forall m{*} a{*} b{*} . (Monad m) => (a{*} -> m{*} (b{*})) -> m{*} (a{*}) -> m{*} (b{*})
flip : forall a{*} b{*} c{*} .  => (a{*} -> b{*} -> c{*}) -> b{*} -> a{*} -> c{*}
fmap : forall f{*} a{*} b{*} . (Functor f) => (a{*} -> b{*}) -> f{*} (a{*}) -> f{*} (b{*})
if : forall a{*} .  => Bool (*) -> a{*} -> a{*} -> a{*}
read : forall a{*} . (Read a) => [Char (*)] -> a{*}
return : forall m{*} a{*} . (Monad m) => m{*} (a{*})
show : forall a{*} . (Show a) => a{*} -> [Char (*)]
~CCons : forall b{*} a{*} .  => (a{*} -> a{*} -> [a{*}] -> b{*}) -> [a{*}] -> b{*}
~Cons : forall b{*} a{*} .  => (a{*} -> [a{*}] -> b{*}) -> [a{*}] -> b{*}
~ConsF : forall b{*} f{* -> *} a{*} .  => (a{*} -> f{* -> *} (a{*}) -> b{*}) -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*}) -> b{*}
~End : forall b{*} a{*} .  => b{*} -> [a{*}] -> b{*}
~EndF : forall b{*} f{* -> *} a{*} .  => b{*} -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*}) -> b{*}
~List : forall b{*} a{*} .  => (ListF ((* -> *) -> * -> *) (List (* -> *)) (a{*}) -> b{*}) -> [a{*}] -> b{*}

Types :
Bool : a
Char : a
Int : a
List : forall a . a -> a
ListF : forall f a . (a -> a) -> a -> a
| : forall a . a -> a -> a


infering : (\f -> (\a -> (\b -> (((f) (b)) (a)))))
solve :
'd should unify with : 'f -> 'g
 'g should unify with : 'e -> 'h

unify : 'd and 'f -> 'g
found : 'd is 'f -> 'g

unify : 'g and 'e -> 'h
found : 'g is 'e -> 'h

found : ('f -> 'e -> 'h) -> 'e -> 'f -> 'h
expected : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
infering : (\a -> (\b -> (((+) (a)) (b))))
solve :
Int -> Int -> Int should unify with : 'a -> 'c
 'c should unify with : 'b -> 'd

unify : Int -> Int -> Int and 'a -> 'c
found : 'a is Int
 'c is Int -> Int

unify : Int -> Int and 'b -> 'd
found : 'b is Int
 'd is Int

found : Int -> Int -> Int
expected : Int -> Int -> Int
after infer : Vars :
* :  => Int (*) -> Int (*) -> Int (*)
+ :  => Int (*) -> Int (*) -> Int (*)
++ : forall a{*} .  => [a{*}] -> [a{*}] -> [a{*}]
- :  => Int (*) -> Int (*) -> Int (*)
. :  => (b{*} -> c{*}) -> (a{*} -> b{*}) -> a{*} -> c{*}
: : forall a{*} .  => a{*} -> [a{*}] -> [a{*}]
== :  => Int (*) -> Int (*) -> Bool (*)
CCons : forall a{*} .  => a{*} -> a{*} -> [a{*}] -> [a{*}]
Cons : forall a{*} .  => a{*} -> [a{*}] -> [a{*}]
ConsF : forall f{* -> *} a{*} .  => a{*} -> f{* -> *} (a{*}) -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*})
End : forall a{*} .  => [a{*}]
EndF : forall f{* -> *} a{*} .  => ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*})
List : forall a{*} .  => ListF ((* -> *) -> * -> *) (List (* -> *)) (a{*}) -> [a{*}]
[] : forall a{*} .  => [a{*}]
add :  => Int (*) -> Int (*) -> Int (*)
bind : forall m{*} a{*} b{*} . (Monad m) => (a{*} -> m{*} (b{*})) -> m{*} (a{*}) -> m{*} (b{*})
flip : forall a{*} b{*} c{*} .  => (a{*} -> b{*} -> c{*}) -> b{*} -> a{*} -> c{*}
fmap : forall f{*} a{*} b{*} . (Functor f) => (a{*} -> b{*}) -> f{*} (a{*}) -> f{*} (b{*})
if : forall a{*} .  => Bool (*) -> a{*} -> a{*} -> a{*}
read : forall a{*} . (Read a) => [Char (*)] -> a{*}
return : forall m{*} a{*} . (Monad m) => m{*} (a{*})
show : forall a{*} . (Show a) => a{*} -> [Char (*)]
~CCons : forall b{*} a{*} .  => (a{*} -> a{*} -> [a{*}] -> b{*}) -> [a{*}] -> b{*}
~Cons : forall b{*} a{*} .  => (a{*} -> [a{*}] -> b{*}) -> [a{*}] -> b{*}
~ConsF : forall b{*} f{* -> *} a{*} .  => (a{*} -> f{* -> *} (a{*}) -> b{*}) -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*}) -> b{*}
~End : forall b{*} a{*} .  => b{*} -> [a{*}] -> b{*}
~EndF : forall b{*} f{* -> *} a{*} .  => b{*} -> ListF ((* -> *) -> * -> *) (f{* -> *}) (a{*}) -> b{*}
~List : forall b{*} a{*} .  => (ListF ((* -> *) -> * -> *) (List (* -> *)) (a{*}) -> b{*}) -> [a{*}] -> b{*}

Types :
Bool : a
Char : a
Int : a
List : forall a . a -> a
ListF : forall f a . (a -> a) -> a -> a
| : forall a . a -> a -> a


checking : (\f -> (\l -> (case (l) of ((~End) (End))
((~Cons) (\a -> (\b -> (((Cons) ((f) (a))) (((fmap) (f)) (b))))))
))) against forall a b . (a -> b) -> [a] -> [b]
solve :
'e -> ['f] -> 'e should unify with : ['g] -> 'h
 'c should unify with : 'k -> 'n
 'm -> ['m] -> ['m] should unify with : 'n -> 'o
 ('q -> 'r) -> 'p 'q -> 'p 'r should unify with : 'c -> 's
 's should unify with : 'l -> 't
 'o should unify with : 't -> 'u
 ('j -> ['j] -> 'i) -> ['j] -> 'i should unify with : ('k -> 'l -> 'u) -> 'v
 'h should unify with : 'd -> 'w
 'h should unify with : 'v

unify : 'e -> ['f] -> 'e and ['g] -> 'h
found : 'e is ['g]
 'h is ['f] -> ['g]

unify : 'c and 'k -> 'n
found : 'c is 'k -> 'n

unify : 'm -> ['m] -> ['m] and 'n -> 'o
found : 'm is 'n
 'o is ['n] -> ['n]

unify : ('q -> 'r) -> 'p 'q -> 'p 'r and ('k -> 'n) -> 's
found : 'q is 'k
 'r is 'n
 's is 'p 'k -> 'p 'n

unify : 'p 'k -> 'p 'n and 'l -> 't
found : 'l is 'p 'k
 't is 'p 'n

unify : ['n] -> ['n] and 'p 'n -> 'u
found : 'p is List
 'u is ['n]

unify : ('j -> ['j] -> 'i) -> ['j] -> 'i and ('k -> ['k] -> ['n]) -> 'v
found : 'i is ['n]
 'j is 'k
 'v is ['k] -> ['n]

unify : ['f] -> ['g] and 'd -> 'w
found : 'd is ['f]
 'w is ['g]

unify : ['f] -> ['g] and ['k] -> ['n]
found : 'f is 'k
 'g is 'n

found : ('k -> 'n) -> ['k] -> ['n]
expected : ('a -> 'b) -> ['a] -> ['b]
checking : (\k -> (1)) against [Char] -> Int
solve :

found : 'a -> Int
expected : [Char] -> Int

Vars :
* : Int -> Int -> Int
+ : Int -> Int -> Int
++ : forall a . [a] -> [a] -> [a]
- : Int -> Int -> Int
. : (b -> c) -> (a -> b) -> a -> c
: : forall a . a -> [a] -> [a]
== : Int -> Int -> Bool
CCons : forall a . a -> a -> [a] -> [a]
Cons : forall a . a -> [a] -> [a]
ConsF : forall f a . a -> f a -> ListF f a
End : forall a . [a]
EndF : forall f a . ListF f a
List : forall a . ListF List a -> [a]
[] : forall a . [a]
add : Int -> Int -> Int
bind : forall m a b . (Monad m) => (a -> m b) -> m a -> m b
flip : forall a b c . (a -> b -> c) -> b -> a -> c
fmap : forall f a b . (Functor f) => (a -> b) -> f a -> f b
if : forall a . Bool -> a -> a -> a
read : forall a . (Read a) => [Char] -> a
return : forall m a . (Monad m) => m a
show : forall a . (Show a) => a -> [Char]
~CCons : forall b a . (a -> a -> [a] -> b) -> [a] -> b
~Cons : forall b a . (a -> [a] -> b) -> [a] -> b
~ConsF : forall b f a . (a -> f a -> b) -> ListF f a -> b
~End : forall b a . b -> [a] -> b
~EndF : forall b f a . b -> ListF f a -> b
~List : forall b a . (ListF List a -> b) -> [a] -> b

Types :
Bool : a
Char : a
Int : a
List : forall a . a -> a
ListF : forall f a . (a -> a) -> a -> a
| : forall a . a -> a -> a

Classes :
Functor :  => ( List)

Monad :  =>

Ord : Eq => (Ord Bool), (Ord Int), (Ord a) => (Ord [a])

Read :  => ( Int)

Show :  => (Show Bool), (Show Int), (Show a) => (Show [a])
